
# 1 2 3 4 5 6 7 8 9 2 4 6 9 6 3 
# 5 3

# 1 2 3
# 4 5 6
# 7 8 9
# 2 4 6
# 9 6 3


[Z0*K+k]sD # D: General delete function, removes TOS silently

# 5sk [lXx lk1-dsk 0<L]sL lk0<L # execute X for k=5..1 if k=5
# 5sk [lXx lkd1-sk 0<L]sL lk0<L # execute X for k=5..0 if k=5
# 5sk [lXx lkd1-sk 0<L]dsLx     # execute X for k=5..1 or for k=0
# 5sk [lXx lk1-dsk 0<L]dsLx     # execute X for k=5..1 or for k=0

# R: Extract a row i from a matrix
# @return matrix row | TOS
# matrix elements entered in reading order numRows numCols | TOS
[
 Si  # Requesting row i
 Sn  # A has n columns
 Sm  # A has m rows
 0Sk
 []SL
 
 [Fetching row ]n lin [ from a matrix with ]n lmn [ rows and ]n lnn [ columns]nAP
 
 # The first i-1 rows have (i-1)*n elements
 # Therefore, skip the first (i-1)*n elements by pushing them onto a named stack A
 #  Try the number of elements in the last m-i rows: (m-i)*n
 [Skipping ]n lmli-ln*n [ elements]nAP
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Row i has n elements
 # Therefore, copy the next n elements by pushing them onto a named stack B along with a stack named A
 [Copying ]n lnn [ elements]nAP
 lnsk [dSBSA lk1-dsk 0<L]sL lk0<L
 
 # Restore the first (i-1)*n + n elements from stack A
 #  Try using last elements again: (m-i)*n + n = (m-i+1)*n
 [Restoring ]n lmli1--ln*n [ elements]nAP
 lmli1--ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 # Restore the n elements that we copied into stack B
 [Restoring ]n lnn [ copied elements]nAP
 lnsk [LB lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
]sR

# E: Fetch element i,j from matrix(m,n)
# @return matrix, element
[
 Sj  # Tgt col j
 Si  # Tgt row i
 Sn  # n cols
 Sm  # m rows
 0Sk
 []SL
 
 lm ln li lRx # get the ith row of matrix(m,n)
 ln  1 lj lRx # get the jth row of matrix(n,1), which is row n transposed
 Se  # Store element as e temporarily
 # We now have n garbage values to destroy
 lnsk [lDx lk1-dsk 0<L]sL lk0<L # so let's delete them
 Le  # Restore element
 
 0LLZ*Li*Lj*Lk*Lm*Ln*K+k
]sE

# w: Write one value to row i, column j
# @return matrix
#  n*(m-i)+(n-j)
#  nm-ni+n-j
#  n(m-n+1)-j
#  lmln-1+ln*lj- # number of elements after i,j
# your matrix newValue rows cols row col | TOS
# your matrix    v       m    n   i   j  | TOS
[
 Sj
 Si
 Sn
 Sm
 Sv
 0Sk
 
 # Move the last n*(m-i)+(n-j) elements into stack A
 lmli-1+ln*lj-sk [SA lk1-dsk 0<L]sL lk0<L
 # Delete existing element
 lDx
 # Insert new element
 Lv
 # Restore last bunch of elements from stack A
 lmli-1+ln*lj-sk [LA lk1-dsk 0<L]sL lk0<L
 
 0LLZ*Lk*Li*Lj*Lm*Ln*K+k
]sw

# W: Write n values to row i of matrix(m,n)
# @return matrix
# matrix values your new row here m n i | TOS
[
 Si
 Sn
 Sm
 0Sk
 []SL
 
 # Push new row of length n onto stack I
 lnsk [SI lk1-dsk 0<L]sL lk0<L
 
 # Push last m-i rows onto stack A
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Delete last n elements, which comprise the existing row i
 lnsk [lDx lk1-dsk 0<L]sL lk0<L
 
 # Copy in the n elements from stack N
 lnsk [LI lk1-dsk 0<L]sL lk0<L
 
 # Copy back the last m-i rows from stack A
 lmli-ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
]sW

# S: Swap rows u and v in matrix(m,n)
# @return matrix
[
 Sv
 Su
 Sn
 Sm
 
 # Pull row u from matrix
 lm ln lu lRx
 # Store u's n elements on stack U
 lnsk [SU lk1-dsk 0<L]sL lk0<L
 # Pull row v from matrix
 lm ln lv lRx
 # Write row v over row u
 lm ln lu lWx
 # Load u's n elements from stack U
 lnsk [LU lk1-dsk 0<L]sL lk0<L
 # Write row u over row v
 lm ln lv lWx
 
 0Lk*Lm*Ln*Lu*Lv*K+k
]sS

# c: Multiply row i by scalar s
# @return matrix row | TOS
# your matrix m n i s | TOS
[
 Ss  # scalar
 Si  # row index
 Sn
 Sm
 0Sk
 []SL
 
##### Copied from R 
 [Fetching row ]n lin [ from a matrix with ]n lmn [ rows and ]n lnn [ columns]nAP
 
 # The first i-1 rows have (i-1)*n elements
 # Therefore, skip the first (i-1)*n elements by pushing them onto a named stack A
 #  Try the number of elements in the last m-i rows: (m-i)*n
 [Skipping ]n lmli-ln*n [ elements]nAP
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Row i has n elements
 # Therefore, copy the next n elements by pushing them onto a named stack B along with a stack named A
 [Copying ]n lnn [ elements]nAP
 lnsk [dSBSA lk1-dsk 0<L]sL lk0<L
 
 # Restore the first (i-1)*n + n elements from stack A
 #  Try using last elements again: (m-i)*n + n = (m-i+1)*n
 [Restoring ]n lmli1--ln*n [ elements]nAP
 lmli1--ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 # Restore the n elements that we copied into stack B
 [Restoring ]n lnn [ copied elements]nAP
 lnsk [LBls* lk1-dsk 0<L]sL lk0<L    # This is the only change from R: s/LB/LBls*/
##### 
 
 
 0LLZ*Li*Lk*Lm*Ln*Ls*K+k
]sc

# +: Row addition
## u := s*u + p*v
# u,v are rows; s,p are scalars
# @return matrix, row
# your matrix m n u s v p | TOS
[
 Sp  # scalar for second row
 Sv  # index of second row
 Ss  # scalar for first row
 Su  # index of first row (row that will be replaced)
 Sn  # columns
 Sm  # rows
 0Sk
 []SL
 
 
 # Get s*u
 lm ln lu ls lKx
 # Store s*u on stack U
 lnsk [SU lk1-dsk 0<L]sL lk0<L
 # Get p*v
 lm ln lv lp lKx
 # Store p*v on stack V
 lnsk [SV lk1-dsk 0<L]sL lk0<L
 # Load each item from U and V and add them together
 lnsk [LULV+ lk1-dsk 0<L]sL lk0<L

# Removed: User will determine what to do with sum of rows, in keeping with style of "don't modify the matrix unless that's all it does"
# # Write s*u + p*v over row u
# lm ln lu lWx
 
 0LLZ*Lk*Lm*Ln*Lp*Ls*Lu*Lv*K+k
]s+

# A: Add scalar multiples of two matrices
# @return A B sA+pB | TOS
# your first matrix your second matrix m n s p | TOS
[
 Sp
 Ss
 Sn
 Sm
 0Sk
 []SL
 
 # Push all m*n elements of second matrix onto stack B
 lmln*sk [SB lk1-dsk 0<L]sL lk0<L
 # Push all m*n elements of first matrix onto stack A
 lmln*sk [SA lk1-dsk 0<L]sL lk0<L
 # For each element:
 #   Copy each pair of elements from A and B
 #   Add A(k)+B(k)
 #   Push each result onto stack C
 #   Load A(k) and B(k)
 lmln*sk [lAls*lBlp*+SCLALB lk1-dsk 0<L]sL lk0<L
 # Now we have C in reverse of the order we need it in,
 # and A and B interleaved on the stack.
 # Separate A and B
 lmln*sk [SBSA lk1-dsk 0<L]sL lk0<L
 # Load A
 lmln*sk [LA lk1-dsk 0<L]sL lk0<L
 # Load B
 lmln*sk [LB lk1-dsk 0<L]sL lk0<L
 # Reverse C into A
 lmln*sk [LCSA lk1-dsk 0<L]sL lk0<L
 # Load C from A
 lmln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 0LLZ*Lk*Lm*Ln*Lp*Ls*K+k
]sA



# P: Print matrix(m,n)
# @return matrix | TOS
[
 Sn  # cols
 Sm  # rows
 0Si
 0Sj
 0Sk
 []SL
 []Sl
 
 # Push all m*n elements onto stack A
 lmln*sk [SA lk1-dsk 0<L]sL lk0<L
  
 # For each row in matrix:
 lmsi [
        [
		 # Copy and print first element of row i
         LAdn
		 # Copy and print the other n-1 elements in row i, preceded by tab spaces
		 ln1-sj [9PLAdn lj1-dsj 0<l]sl lj0<l
		 # Print trailing newline
		 AP
		]x
		li1-dsi 0<L]sL li0<L
 
 0LLZ*LlZ*Li*Lj*Lk*Lm*Ln*K+k
]sP

# Tests
#1 2 3 4 5 6 7 8 9
#5 3 1 lRxf

#3 3 1 3 lSxfAdPP
#3 3 2 3 lSxfAdPP

#0 0 0 3 3 2 lWxfAdPP
#386 3 3 2 2 lwxfAdPP

0 1 2 3 4 5 6 7 8
9 8 7 6 5 4 3 2 1
