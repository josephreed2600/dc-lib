
# 1 2 3 4 5 6 7 8 9 2 4 6 9 6 3 
# 5 3

# 1 2 3
# 4 5 6
# 7 8 9
# 2 4 6
# 9 6 3


[Z0*K+k]sD # D: General delete function, removes TOS silently

# 5sk [lXx lk1-dsk 0<L]sL lk0<L # execute X for k=5..1 if k=5
# 5sk [lXx lkd1-sk 0<L]sL lk0<L # execute X for k=5..0 if k=5
# 5sk [lXx lkd1-sk 0<L]dsLx     # execute X for k=5..1 or for k=0
# 5sk [lXx lk1-dsk 0<L]dsLx     # execute X for k=5..1 or for k=0

# R: Extract a row i from a matrix
# matrix elements listed in reading order numRows numCols | TOS
[
 Si  # Requesting row i
 Sn  # A has n columns
 Sm  # A has m rows
 0Sk
 []SL
 
 [Fetching row ]n lin [ from a matrix with ]n lmn [ rows and ]n lnn [ columns]nAP
 
 # The first i-1 rows have (i-1)*n elements
 # Therefore, skip the first (i-1)*n elements by pushing them onto a named stack A
 #  Try the number of elements in the last m-i rows: (m-i)*n
 [Skipping ]n lmli-ln*n [ elements]nAP
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Row i has n elements
 # Therefore, copy the next n elements by pushing them onto a named stack B along with a stack named A
 [Copying ]n lnn [ elements]nAP
 lnsk [dSBSA lk1-dsk 0<L]sL lk0<L
 
 # Restore the first (i-1)*n + n elements from stack A
 #  Try using last elements again: (m-i)*n + n = (m-i+1)*n
 [Restoring ]n lmli1--ln*n [ elements]nAP
 lmli1--ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 # Restore the n elements that we copied into stack B
 [Restoring ]n lnn [ copied elements]nAP
 lnsk [LB lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
]sR

# E: Fetch element i,j from matrix(m,n)
[
 Sj  # Tgt col j
 Si  # Tgt row i
 Sn  # n cols
 Sm  # m rows
 0Sk
 []SL
 
 lm ln li lRx # get the ith row of matrix(m,n)
 ln  1 lj lRx # get the jth row of matrix(n,1), which is row n transposed
 Se  # Store element as e temporarily
 # We now have n garbage values to destroy
 lnsk [lDx lk1-dsk 0<L]sL lk0<L # so let's delete them
 Le  # Restore element
 
 0LLZ*Li*Lj*Lk*Lm*Ln*K+k
]sE

# w: Write one value to row i, column j
#  n*(m-i)+(n-j)
#  nm-ni+n-j
#  n(m-n+1)-j
#  lmln-1+ln*lj- # number of elements after i,j
# your matrix newValue rows cols row col | TOS
# your matrix    v       m    n   i   j  | TOS
[
 Sj
 Si
 Sn
 Sm
 Sv
 0Sk
 
 # Move the last n*(m-i)+(n-j) elements into stack A
 lmli-1+ln*lj-sk [SA lk1-dsk 0<L]sL lk0<L
 # Delete existing element
 lDx
 # Insert new element
 Lv
 # Restore last bunch of elements from stack A
 lmli-1+ln*lj-sk [LA lk1-dsk 0<L]sL lk0<L
 
 0LLZ*Lk*Li*Lj*Lm*Ln*K+k
]sw

# W: Write n values to row i of matrix(m,n)
# matrix values your new row here m n i | TOS
[
 Si
 Sn
 Sm
 0Sk
 []SL
 
 # Push new row of length n onto stack I
 lnsk [SI lk1-dsk 0<L]sL lk0<L
 
 # Push last m-i rows onto stack A
 lmli-ln*sk [SA lk1-dsk 0<L]sL lk0<L
 
 # Delete last n elements, which comprise the existing row i
 lnsk [lDx lk1-dsk 0<L]sL lk0<L
 
 # Copy in the n elements from stack N
 lnsk [LI lk1-dsk 0<L]sL lk0<L
 
 # Copy back the last m-i rows from stack A
 lmli-ln*sk [LA lk1-dsk 0<L]sL lk0<L
 
 
 0LLZ*Li*Lk*Lm*Ln*K+k
]sW

# S: Swap rows u and v in matrix(m,n)
[
 Sv
 Su
 Sn
 Sm
 
 # Pull row u from matrix
 lm ln lu lRx
 # Store u's n elements on stack U
 lnsk [SU lk1-dsk 0<L]sL lk0<L
 # Pull row v from matrix
 lm ln lv lRx
 # Write row v over row u
 lm ln lu lWx
 # Load u's n elements from stack U
 lnsk [LU lk1-dsk 0<L]sL lk0<L
 # Write row u over row v
 lm ln lv lWx
 
 0Lk*Lm*Ln*Lu*Lv*K+k
]sS


# Tests
1 2 3 4 5 6 7 8 9
#5 3 1 lRxf

3 3 1 3 lSxfAdPP
3 3 2 3 lSxfAdPP

0 0 0 3 3 2 lWxfAdPP
386 3 3 2 2 lwxfAdPP
