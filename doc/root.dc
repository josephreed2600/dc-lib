[

# take arguments from stack

SbdSaSA

# initialize and declare some functions
[]SI
[]SL
[]SM
[]SN
[]ST
0SK

[v]SO
[lb^]SF

# execute a=O(a) until F(a)<A
# id est, a=sqrt(a) until a^b<A
[lalOxdsalFxlA<L]sL lalFxlA<L

# redefine O() to increment by 10^(-K)
[10lK_1*^+]sO

# define M(a), which we will run later
# increment a by 1/(10^K) until F(a)>A, then decrement so that F(a)<=A
[[lalOxdsalFxlA>L]sL lalFxlA>L la10lK_1*^-sa]sM

# execute M() until K==scale
# id est, repeat for every decimal place
[lK1+sKlMxlKK>N]sN lKK>N

# catch the case where the value is one fractional unit less than the correct result
# if this is the case, then incrementing will yield an exact answer
[[sa]sT]sI [0*K+k]sT lalOxdlA=I lTx

# clean up our mess
0LFZ*LIZ*LLZ*LMZ*LNZ*LOZ*LTZ*LA*Lb*LK*K+k

# push our return value
La

]sV
